<!DOCTYPE html> <!-- Defines the document type and version of HTML -->
<html>

<head>
    <meta charset="UTF-8"> <!-- Sets the character encoding for the document -->
    <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Ensures the site is mobile-friendly -->
    <style>
        /*
            MSU Hex Code Colors:
            Spartan Green:      #18453B
            White:              #FFFFFF
            Black:              #000000
            Kelly Green:        #008208
            Lime Green:         #7BBD00
            Excellence Green:   #0B9A6D
            Refresh Green:      #008934
        */

        body {
            margin: 0;
            padding: 0;
            display: flex; /* Use flexbox for layout */
            flex-direction: column; /* Stack flex items vertically */
            align-items: center; /* Center-align items horizontally */
            justify-content: space-around; /* Even spacing of children */
            height: 100vh; /* Full viewport height */
            font-family: Arial, sans-serif; /* Font style for the body */
            color: white;
        }

        /* CSS styles for the result display area */
        #result {
            width: 90%; /* Take up 90% of the parent's width */
            height: 200px; /* Fixed height */
            border: 2px solid #333; /* Solid border with color */
            border-radius: 5px; /* Rounded corners */
            font-size: 24px; /* Text size */
            text-align: center; /* Center text horizontally */
            display: flex; /* Use flexbox for layout */
            align-items: center; /* Center-align items vertically */
            justify-content: center; /* Center content horizontally */
            color: #18453b;
        }

        /* CSS styles for the title div */
        #title {
            width: 90%; /* Take up 90% of the parent's width */
            height: 100px; /* Fixed height */
            border: 2px solid #333; /* Solid border with color */
            border-radius: 5px; /* Rounded corners */
            font-size: 24px; /* Text size */
            text-align: center; /* Center text horizontally */
            display: flex; /* Use flexbox for layout */
            align-items: center; /* Center-align items vertically */
            justify-content: center; /* Center content horizontally */
            background-color: #18453b;
        }

        /* CSS styles for the record and stop buttons */
        #button,
        #button2 {
            width: 100px; /* Fixed width */
            height: 100px; /* Fixed height */
            border-radius: 50%; /* Make it a circle */
            color: #fff; /* Text color */
            background-color: #18453B; /* Background color */
            text-align: center; /* Center text horizontally */
            display: flex; /* Use flexbox for layout */
            align-items: center; /* Center-align items vertically */
            justify-content: center; /* Center content horizontally */
            font-size: 20px; /* Text size */
            cursor: pointer; /* Change mouse cursor to pointer */
        }

        /* Additional CSS styles for the stop button to differentiate it */
        #button2 {
            background-color: #ff0000; /* Red background color */
        }

        #display {
            margin-top: 20px;
            max-width: 100%;
            height: auto;
        }

        /* Style the button that is used to open and close the collapsible content */
        .collapsible {
          background-color: #18453B;
          color: #FFFFFF;
          cursor: pointer;
          padding: 18px;
          width: 100%;
          border: none;
          text-align: center;
          outline: none;
          font-size: 15px;
        }

        .collapsible:after {
          content: '\0FF3E'; /* Unicode character for "caret" sign (^) */
          font-size: 13px;
          color: white;
          float: center;
          margin-left: 5px;
        }

        .active:after {
          content: "\2796"; /* Unicode character for "minus" sign (-) */
        }

        /* Add a background color to the button if it is clicked on (add the .active class with JS), and when you move the mouse over it (hover) */
        .active, .collapsible:hover {
          background-color: #008208;
        }

        /* Style the collapsible content. Note: hidden by default */
        .content {
          padding: 0 18px;
          background-color: white;
          max-height: 0;
          overflow: hidden;
          transition: max-height 0.2s ease-out;
          color: #18453b
        }
    </style>
</head>

<body>
    <!-- Title div displaying the name of the application -->
    <div id="title">MSU RCPD Sound Identification System</div>
    <!-- Button that initiates audio recording -->
    <div id="button" onclick="startFunc()">Record</div>
    <!-- Button that stops audio recording, initially hidden -->
    <div id="button2" style="display: none;" onclick="stopFunc()">Stop Record</div>
    <button type="button" class="collapsible">Sound Identification Results</button>
    <!-- Div that will display the result of the sound analysis -->
    <div class="content" id ="soundIdentificationResults"></div>

    <!-- JavaScript files required for recording functionality -->
    <script src="/static/js/recorder-core.js"></script>
    <script src="/static/js/wav.js"></script>

    <!-- Inline JavaScript code that handles the audio recording logic -->
    <script>
        // Variables to store the recorder instance, the WAV encoder, and the final blob of audio data
        var rec, wave, recBlob;
        // A flag to control the stop and start of recording
        var stop = false;

        // Function to initialize the recorder instance
        var recOpen = function () {
            // Reset the recorder and audio data variables
            rec = null;
            wave = null;
            recBlob = null;
            // Create a new recorder instance with specified settings
            var newRec = Recorder({
                // Output format
                type: "wav", 
                // Sample rate for recording
                sampleRate: 16000, 
                // Bit rate for recording
                bitRate: 16,
                //Recording real-time callback, called approximately 12 times per second
                onProcess: function (buffers, powerLevel, bufferDuration, bufferSampleRate, newBufferIdx, asyncEnd) {
                }
            });

            // Attempt to open the recorder, asking the user for microphone permissionss
            newRec.open(function () {//Get microphone access
                // On success, assign the new recorder instance to the 'rec' variable
                rec = newRec;
                reclog("Recording has been turned on. You can click Record to start recording.", 2);
            }, function (msg, isUserNotAllow) {//access refuse
                reclog((isUserNotAllow ? "UserNotAllow，" : "") + "Failed to start recording:" + msg, 1);
            });
        };
        recOpen()

        /**Turn off recording and release resources**/
        function recClose() {
            if (rec) {
                // If there is an active recorder instance, close it to release resources such as the microphone
                rec.close();
                // Log the status indicating the recorder has been turned off
                reclog("Turned off");
            } else {
                // Log a warning if the recClose function is called without an active recording session
                reclog("Recording is not turned on", 1);
            };
        };

        /**start recording**/
        function recStart() {
            // Check if the recorder is initialized and if the microphone access is open
            if (rec && Recorder.IsOpen()) {
                // Reset the recorded audio blob to null to prepare for a new recording session
                recBlob = null;
                // Start the recording process
                rec.start();
                // Log that recording has started
                reclog("recording has started...");
                setTimeout(function () {
                    // Automatically call recStop after 5 seconds to stop recording
                    recStop()
                }, 5000);
            } else {
                // Log an error if recStart is called but the recorder is not ready
                reclog("Recording is not turned on", 1);
            };
        };

        /**End recording and get audio files**/
        function recStop() {
            // Check if the recorder is not initialized or if the microphone access is not open
            if (!(rec && Recorder.IsOpen())) {
                // Log an error if recStop is called without a proper recording session
                reclog("Recording is not turned on", 1);
                // Exit the function early if there is no active recording session
                return;
            };
            // Stop the recording and execute the callback function with the recorded audio blob and its duration
            rec.stop(function (blob, duration) {
                // Log the blob information and its URL for playback
                console.log(blob, (window.URL || webkitURL).createObjectURL(blob), "duration:" + duration + "ms");

                // Assign the recorded audio blob to recBlob variable for later use
                recBlob = blob;
                reclog("recorded wav:" + formatMs(duration) + "ms " + blob.size + "Bytes, you can click to play, upload, and download locally", 2);
                // Upload the recorded audio immediately after stopping the recording
                recUpload()
            }, function (msg) {
                // Log an error if stopping the recording process fails
                reclog("Recording failed:" + msg, 1);
            });
        };

        /**upload**/
        function recUpload() {
            // Retrieve the recorded audio blob from the recBlob variable
            var blob = recBlob;
            if (!blob) {
                // Log a warning if there is no recorded audio blob to upload
                reclog("record first, then stop before uploading", 1);
                // Exit the function if there is nothing to upload
                return;
            };

            // Define the server endpoint for audio analysis
            var api = "/api/analyze-audio";
            var onreadystatechange = function (title) {
                return function () {
                    // Check if the XMLHttpRequest is completed
                    if (xhr.readyState == 4) {
                        // Check if the HTTP request was successful
                        if (xhr.status == 200) {
                            // Log the success of the upload
                            reclog(title + "upload success", 2);
                        } else {
                            // Log a warning if the upload is not completed successfully
                            reclog(title + "upload not completed", "#d8c1a0");
                            // Log an error if the upload fails
                            console.error(title + "failed to upload", xhr.status, xhr.responseText);
                        };
                    };
                };
            };
            // Log that the upload process has started
            reclog("start upload" + api + ",wait...");
            // Create a new FormData object to hold the audio file for the POST request
            const formData = new FormData();
            // Append the audio blob to the form data with a filename
            formData.append('audio', blob, "recorder.wav");

            // Make a POST request to the server endpoint to analyze the audio
            fetch('/api/analyze-audio', {
                // HTTP method
                method: 'POST',
                // The audio data to be sent
                body: formData
            })
                .then(function (response) {
                    // Retrieve the text response from the server
                    return response.text();
                })
                .then(function (result) {
                    // Display the result from the server in the UI
                    displayResult(result);
                    if (!stop) {
                        // If the 'stop' flag is not set, start recording again automatically
                        recStart()
                    }
                })
                .catch(function (error) {
                    // Log any errors that occur during the fetch operation
                    console.error('Error sending audio data:', error);
                });
        };

        // This function is called when the user clicks the "Record" button.
        // It prepares the application to start recording.
        function startFunc() {
            // Setting the 'stop' flag to false to indicate recording is active
            stop = false;
            // Calling the function to start recording
            recStart()

            // Hiding the "Record" button by changing its CSS display property to 'none'
            document.getElementById('button').style = "display: none";
            // Showing the "Stop Record" button by clearing any inline display style, defaults to 'flex' from the stylesheet
            document.getElementById('button2').style = "";
            // Displaying a message to the user that the system is analyzing the sound
            displayResult("Analyzing...")
        }

        // This function is called when the user clicks the "Stop Record" button.
        // It signals the application to stop recording.
        function stopFunc() {
            // Setting the 'stop' flag to true to indicate recording should stop
            stop = true;
            // Calling the function to stop recording
            recStop()

            // recUpload()
            // Showing the "Record" button by clearing any inline display style
            document.getElementById('button').style = "";
            // Hiding the "Stop Record" button by changing its CSS display property to 'none'
            document.getElementById('button2').style = "display: none";
        }

        // A helper function to log messages to the browser console
        function reclog(result) {
            // Output the result to the console for debugging
            console.log(result)
        }

        // This function updates the text content of the 'result' div to display messages to the user
        function displayResult(result) {
            // Setting the text content of the 'result' div to whatever result is passed to the function
            document.getElementById('soundIdentificationResults').innerHTML = result;

            // Automatically open the collapsible when sound is detected
            document.querySelector('.collapsible').click();
        }

        // A utility function to format milliseconds into a human-readable string
        var formatMs = function (ms, all) {
            // Calculating the minutes and seconds from milliseconds
            var f = Math.floor(ms / 60000), m = Math.floor(ms / 1000) % 60;
            // Building a string 's' that represents time in "minutes:seconds"
            var s = (all || f > 0 ? (f < 10 ? "0" : "") + f + ":" : "")
                + (all || f > 0 || m > 0 ? ("0" + m).substr(-2) + "″" : "")
                + ("00" + ms % 1000).substr(-3);
            // Returning the formatted time string
            return s;
        };
    </script>

    <!-- Inline JavaScript code that handles the bottom collapsible logic -->
    <script>
        var coll = document.getElementsByClassName("collapsible");
        var i;

        for (i = 0; i < coll.length; i++) {
          coll[i].addEventListener("click", function() {
            this.classList.toggle("active");
            var content = this.nextElementSibling;
            if (content.style.maxHeight){
              content.style.maxHeight = null;
            } else {
              content.style.maxHeight = content.scrollHeight + "px";
            }
          });
        }
    </script>
</body>


</html>